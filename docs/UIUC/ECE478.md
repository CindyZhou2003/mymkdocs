# Formal Software Development Methods





[Rice's theorem](https://en.wikipedia.org/wiki/Rice's_theorem) states that **no algorithm can determine all non-trivial properties about the language recognized by a Turing machine** **(or any [Turing-complete program](https://www.google.com/search?q=Turing-complete+program&rlz=1C5BAPC_enUS1177US1177&oq=rice+ther&gs_lcrp=EgZjaHJvbWUqCwgBEAAYChgLGIAEMgYIABBFGDkyCwgBEAAYChgLGIAEMhEIAhAuGAoYCxivARjHARiABDIHCAMQABiABDILCAQQABgKGAsYgAQyBwgFEAAYgAQyCwgGEAAYChgLGIAEMgcIBxAAGIAEMgsICBAAGAoYCxiABDIGCAkQABge0gEJNTE3MWowajE1qAIIsAIB8QXoRuU48kLmmg&sourceid=chrome&ie=UTF-8&ved=2ahUKEwiErczb8JqSAxVOw8kDHZ2VJ5IQgK4QegYIAQgAEAc))**, meaning it's impossible to know for any given program if it possesses an interesting behavioral characteristic, like whether it halts or accepts specific inputs, without running it (which might not even finish)



### Set

<img src="./assets/image-20260122125518904.png" alt="image-20260122125518904" style="zoom:50%;" />

**Cartesian product** 笛卡尔积

-   If $C = \{1, 5, 7\}$, $B = \{2, 3, 5, 7\}$, then $$C \times B = \{(1, 2), (1, 3), (1, 5), (1, 7), (5, 2), (5, 3), (5, 5), (5, 7), (7, 2), (7, 3), (7, 5), (7, 7)\}$$

**Difference**

-   $A \setminus C$ consists of all elements that are in $A$ but not in $C$.

**Powerset**

-   If $A = \{1, 2, 4, 7\}$, $C = \{1, 5, 7\}$, then the powerset of $$A \cap C$$ denoted as $2^{A∩C}$ is $$\mathcal{P}(A \cap C) = \left\{ \emptyset, \{1\}, \{7\}, \{1, 7\} \right\}$$

### Relation

| Property      | Definition                                                  |
| ------------- | ----------------------------------------------------------- |
| Reflexive     | If for every $x \in \mathbb{Z}$, $(x, x) \in R$             |
| Symmetric     | If $(x, y) \in R$ implies $(y, x) \in R$                    |
| Transitive    | If $(x, y) \in R$ and $(y, z) \in R$ implies $(x, z) \in R$ |
| Antisymmetric | If $(x, y) \in R$ and $(y, x) \in R$, then $x = y$.         |

-   **Equivalence**: reflexive+symetric+transitive
-   **Partial order**: reflexive+antisymmetric+transitive
-   **Preorder**: reflexive+transitive

Binary Relation



### Function

A particular input has a single output

Computations not a function?

### Language

Alphabet, language, words

Regular expression

syntax+semantics

#### Simple imperative Programming language

### Syntax->Graph

Graph(V, E)

Parse tree

Flow graph

DAG(Directed A~ Graph)

**CFG(control flow graph)**

-   A CFG is *a conservative approximation of the control flow* 
    -   The CFG is built using **static analysis**, meaning it only looks at the code's structure (syntax) without actually running it. It cannot always determine the actual values of variables during execution (semantics). It guarantees that no real execution path is ever missing, at the cost of including "fake" paths.


Basic Block

-   Statements execute in sequence

Dynamic semantics



Binary Relations



## Small step semantics

### Interpreter

$[node, {var ↦ value}] → ⟨edge⟩ → [node, {var ↦ value}]$

The `{parameter↦value}` part represents the **current state** of the program variables at a specific node.

`(C, m)` represents a "configuration" or "machine state," where `C` is the code remaining to be executed, and `m` is the current memory state.

The arrow `-->` represents exactly one step of computation. The program transforms from one state `(C1, m1)` to the next `(C2, m2)` until it reaches `skip` (which means "done"), leaving only the final memory `m`.

`-->*`: the **transitive closure** of the single-step arrow

-   It is the "smallest transitive relation" connecting a starting state to any future state.





Example:`if x > 5 then y := 2 + 3 else y := 3 + 4 fi`

-   Initial Memory ($m$): `{x -> 7}`

1.  **Evaluate Condition:** The interpreter looks at `x > 5`. It looks up `x` in memory (which is 7) and evaluates `7 > 5` to `true`.
    -   *Transition:* The code rewrites itself to: `if true then ...`
2.  **Branch Selection:** Since the condition is `true`, the `if` rule selects the first command (the "then" branch).
    -   *Transition:* The code rewrites itself to just: `y := 2 + 3`
3.  **Evaluate Expression:** The assignment needs a value, not math. It calculates `2 + 3`.
    -   *Transition:* The code rewrites itself to: `y := 5`
4.  **Update Memory:** Now that we have a simple assignment `y := 5`, we update the memory.
    -   *Transition:* The code becomes `skip` (finished), and the memory becomes `{x -> 7, y -> 5}`.

#### Par机制

The `par` (parallel) command allows two threads to run at the same time. The semantics rules state that at any step, the scheduler can essentially flip a coin to decide which side gets to run next. 两个线程可同时运行

Example: $$((Y := 1) \ \mathbf{par} \ (\text{while } Y = 0 \text{ do } X := X + 1), \ \{X \to 0, Y \to 0\})$$

-   Initial x=0, y=0

-   Outcome A: The "Stop" Button works immediately

    1.  Left side runs: `Y:= 1` executes immediately. $Y$ becomes 1.
    2.  Right side runs: The loop checks `while Y == 0`. Since $Y$ is now 1, the condition fails. The loop terminates.
    3.  Final State: $X = 0, Y = 1$.

-   Outcome B: The "Loop" sneaks in a run

    1.  Right side runs: The loop checks `while Y == 0`. It is true. The body `X:= X + 1` runs. $X$ becomes 1.
    2.  Left side runs: `Y:= 1` executes. $Y$ becomes 1.
    3.  Right side runs: The loop checks `while Y == 0`. False. Terminate.
    4.  Final State: $X = 1, Y = 1$.

-   Outcome C: The "Loop" runs forever (or for a long time)

    Because there is no rule forcing the Left side to run, the Right side could theoretically keep winning the "coin flip" 100 times, 1,000 times, or forever.

    -   Final State: $X = \text{any integer } n \ge 0$.



### Big steps

Arithmetic Expressions ($\langle a, \sigma \rangle \Downarrow v$ )

Commands ($\langle c, \sigma \rangle \Downarrow \sigma'$) 

-   Assignment: $${\langle x := a, \sigma \rangle \Downarrow \sigma}$$
-   Sequence:$${\langle c_1; c_2, \sigma \rangle \Downarrow \sigma}$$
-   If/while: $$\langle \textbf{if } b \textbf{ then } c_1 \textbf{ else } c_2, \sigma \rangle$$



